#include "environment.h"
#include <windows.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include "tokenizer.h"

using namespace std;

#define START_PORT 55023
#define MAX_PORT_COUNT 255

// This implementation is autogenerated to default.conf.cpp
void WriteDefaultConf(std::ofstream& stream);

// This implementation is autogenerated to php.ini.cpp
void WritePhpIni(std::ofstream& stream);

Environment::Environment()
    : _ok(false)
{
    HMODULE hModule = GetModuleHandle(NULL);
    char path[MAX_PATH];
    GetModuleFileName(hModule, path, MAX_PATH);

    int i = 0;
    while (path[i] != '\0')
        if (path[i++] == '\\') path[i-1] = '/';

    this->_approot = path;
    this->_approot = this->_approot.substr(0, this->_approot.find_last_of('/'));

    this->_httpd = this->_approot + "/httpd/bin/httpd.exe";
    this->_php = this->_approot + "/php/php.exe";
    this->_phpIni = this->_approot + "/php.ini";
    this->_defaultConf = this->_approot + "/default.conf";
    this->_vhostsDirectory = this->_approot + "/vhosts/";

    if (FileExists(this->_defaultConf) == false)
    {
        ofstream defaultConfFile;
        defaultConfFile.open(this->_defaultConf.c_str());
        WriteDefaultConf(defaultConfFile);
        defaultConfFile.close();
    }

    if (FileExists(this->_phpIni) == false)
    {
        ofstream phpIniFile;
        phpIniFile.open(this->_phpIni.c_str());
        WritePhpIni(phpIniFile);
        phpIniFile << "extension_dir=\"" << this->_approot << "/php/ext\"" << endl;
        phpIniFile.close();
    }

    if (DirectoryExists(this->_vhostsDirectory) == false)
    {
        if (CreateDirectory(this->_vhostsDirectory.c_str(), NULL) == 0)
        {
            cout << "Unable to create vhost folder(" << this->_vhostsDirectory << "), should you run this in your homefolder?" << endl;
            return;
        }
    }

    if (FileExists(this->_httpd) == false)
    {
        cout << "Did not find Apache httpd installation (httpd.exe) in the correct location. Must be in: " << this->_httpd << "."  << endl;
        return;
    }

    if (FileExists(this->_php) == false)
    {
        cout << "Did not find PHP installation (php.exe) in the correct location. Must be in: " << this->_php << "."  << endl;
        return;
    }

    this->_localConf = this->_approot + "/local.conf";

    ofstream localConfFile;
    localConfFile.open(this->_localConf.c_str());
    localConfFile << "ServerName \"localhost\"" << endl << endl;

    localConfFile << "Include \"" << this->_approot << "/default.conf\"" << endl;
    localConfFile << "Include \"" << this->_approot << "/vhosts\"" << endl << endl;

    localConfFile << "ServerRoot \"" << this->_approot << "/httpd\"" << endl;
    localConfFile << "LoadModule php5_module \"" << this->_approot << "/php/php5apache2_4.dll\"" << endl;
    localConfFile << "PHPIniDir \"" << this->_approot << "/\"" << endl << endl;

    localConfFile << "AddHandler application/x-httpd-php .php" << endl;
    localConfFile << "<FilesMatch \\.php$>" << endl;
    localConfFile << "      SetHandler application/x-httpd-php" << endl;
    localConfFile << "</FilesMatch>" << endl << endl;

    localConfFile.close();

    this->_ok = true;
}

Environment::~Environment()
{ }

std::string Environment::CreateProject(const std::string& projectFolder, const std::string& projectName)
{
    string projectConf = this->_vhostsDirectory + projectName + ".conf";
    string projectPort;
    if (Environment::FileExists(projectConf))
        projectPort = this->GrabPort(projectConf);

    if (projectPort == "")
        projectPort = this->GeneratePort();

    ofstream vhostFile;
    vhostFile.open(projectConf.c_str());
    vhostFile << "Listen " << projectPort << endl << endl;
    vhostFile << "<VirtualHost *:" << projectPort << ">" << endl;
    vhostFile << "    ServerAdmin webmaster@" << projectName << "" << endl;
    vhostFile << "    DocumentRoot \"" << projectFolder + "\"" << endl;
    vhostFile << "    <Directory \"" << projectFolder + "\">" << endl;
    vhostFile << "        Options Indexes FollowSymLinks" << endl;
    vhostFile << "        AllowOverride None" << endl;
    vhostFile << "        Require all granted" << endl;
    vhostFile << "    </Directory>" << endl;
    vhostFile << "    ServerName " << projectName << "" << endl;
    vhostFile << "    ServerAlias " << projectName << "" << endl;
    vhostFile << "    ErrorLog \"logs/" << projectName << "-error.log\"" << endl;
    vhostFile << "    CustomLog \"logs/" << projectName << "-access.log\" common" << endl;
    vhostFile << "</VirtualHost>" << endl;
    vhostFile.close();

    return string("http://localhost:" + projectPort + "/");
}

bool Environment::DeleteProject(const std::string& projectName)
{
    string projectConf = this->_vhostsDirectory + projectName + ".conf";
    return (DeleteFile(projectConf.c_str()) != 0);
}

std::string Environment::GrabPort(const std::string& projectConf)
{
    ifstream projectConfFile(projectConf.c_str());
    if (projectConfFile.is_open())
    {
        string line, port;
        while (projectConfFile.good())
        {
            getline(projectConfFile, line);
            common::Tokenizer tok(line.c_str(), line.size());
            if (string(tok.GetNextToken()) == "Listen" && tok.NextToken())
            {
                port = string(tok.GetToken());
                break;
            }
        }
        projectConfFile.close();
        return port;
    }

    return "";
}

std::string Environment::GeneratePort()
{
    int ports[MAX_PORT_COUNT] = { 0 };
    HANDLE hFind;
    WIN32_FIND_DATA data;
    string pattern = this->_vhostsDirectory + "*.conf";
    hFind = FindFirstFile(pattern.c_str(), &data);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            string port = this->GrabPort(this->_vhostsDirectory + string(data.cFileName));
            if (port != "")
            {
                int i = atoi(port.c_str()) - START_PORT;
                if (i < MAX_PORT_COUNT)
                    ports[i] = 1;
            }
        }
        while (FindNextFile(hFind, &data));
        FindClose(hFind);
    }
    for (int i = 0; i < MAX_PORT_COUNT; i++)
    {
        if (ports[i] == 0)
        {
            stringstream ss;
            ss << (START_PORT + i);
            return ss.str();
        }
    }
    return "";
}

std::string Environment::BuildCommandLine()
{
    return this->_httpd + " -f \"" + this->_approot + "/local.conf\"";
}

bool Environment::FileExists(string& file)
{
   WIN32_FIND_DATA FindFileData;
   HANDLE handle = FindFirstFile(file.c_str(), &FindFileData) ;

   if (handle != INVALID_HANDLE_VALUE)
   {
       //FindClose(&handle); this will crash
       FindClose(handle);
       return true;
   }
   return false;
}

bool Environment::DirectoryExists(string& file)
{
  DWORD dwAttrib = GetFileAttributes(file.c_str());

  return (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}
